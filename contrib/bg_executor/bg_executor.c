/*-------------------------------------------------------------------------
 *
 * bg_executor.c
 *		  Background executor for executing PlannedStmt generated by postgres
 *
 * Portions Copyright (c) 2012-2016, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *			contrib/bg_executor/bg_executor.c
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include "bg_executor.h"

/* These are always necessary for a bgworker */
#include "miscadmin.h"
#include "postmaster/bgworker.h"
#include "storage/ipc.h"
#include "storage/latch.h"
#include "storage/lwlock.h"
#include "storage/proc.h"
#include "storage/shmem.h"

/* these headers are used by this particular worker's code */
#include "access/xact.h"
#include "executor/executor.h"
#include "executor/spi.h"
#include "fmgr.h"
#include "lib/stringinfo.h"
#include "pgstat.h"
#include "utils/builtins.h"
#include "utils/snapmgr.h"
#include "tcop/utility.h"

PG_MODULE_MAGIC;

void		_PG_init(void);
void		bg_executor_main(Datum) pg_attribute_noreturn();
void bg_executor_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction,
		uint64 count);

extern MemoryContext TopTransactionContext;

/* flags set by signal handlers */
static volatile sig_atomic_t got_sighup = false;
static volatile sig_atomic_t got_sigterm = false;

/* GUC variables */
static int	bg_executor_naptime = 5;
static int	bg_executor_total_numbers = 2;
static shmem_startup_hook_type prev_shmem_startup_hook = NULL;

/* global variables */
HTAB *bgExecutorHash = NULL;
BackgroundWorkerHandle **bgExecutorHandles = NULL;

/* static functions */
static Queue * InitQueue(int32 executorId);
static void EnQueue(Queue *queue, StringInfo buf);
static void DeQueue(Queue *queue, StringInfo buf);
static bool IsQueueEmpty(Queue *queue);
static bool IsQueueFull(Queue *queue);
static void RegisterBgExecutorQueue(Queue *queue);
static Size BgExecutorShmemSize(void);
static void BgExecutorShmemInit(void);
static void LaunchBackgroundExecutors(void);
static void TerminateBackgroundExecutors(void);

static Queue *
InitQueue(int32 executorId)
{
	char executorName[BGW_MAXLEN];
	Queue *queue = (Queue *) ShmemAlloc(sizeof(Queue));
	queue->trancheId = LWLockNewTrancheId();
	queue->executorId = executorId;
	memset(executorName, 0, BGW_MAXLEN);
	snprintf(executorName, BGW_MAXLEN, "bgexecutor-%06d", executorId);
	/*
	 * TODO: lwlock.h says that "each individual process using the tranche should
	 * call LWLockRegisterTranche() to associate that tranche ID with a name.",
	 * currently we haven't done so and it seems to be okay, make sure of it.
	 */
	LWLockRegisterTranche(queue->trancheId, executorName);
	LWLockInitialize(&queue->lwlock, queue->trancheId);
	return queue;
}

static void
EnQueue(Queue *queue, StringInfo buf)
{
	for (;;)
	{
		LWLockAcquire(&queue->lwlock, LW_EXCLUSIVE);
		if (queue->size == MaxQueueSize)
		{
			LWLockRelease(&queue->lwlock);
			/*
			 * TODO: any epoll strategy?
			 */
			pg_usleep(1 * 1000L);
		}
		else
		{
			queue->elems[queue->tail].ptr = (char *) ShmemAlloc(buf->len);
			memcpy(queue->elems[queue->tail].ptr, buf->data, buf->len);
			queue->elems[queue->tail].size = buf->len;
			queue->size++;
			queue->tail++;
			if (queue->tail == MaxQueueSize)
			{
				queue->tail = 0;
			}
			LWLockRelease(&queue->lwlock);
			break;
		}
	}
}

static void
DeQueue(Queue *queue, StringInfo buf)
{
	for (;;)
	{
		LWLockAcquire(&queue->lwlock, LW_EXCLUSIVE);
		if (queue->size == 0)
		{
			LWLockRelease(&queue->lwlock);
			pg_usleep(1 * 1000L);
		}
		else
		{
			QueueElem *elem = &queue->elems[queue->head];
			resetStringInfo(buf);
			appendBinaryStringInfo(buf, elem->ptr, elem->size);
			queue->size--;
			queue->head++;
			if (queue->head == MaxQueueSize)
			{
				queue->head = 0;
			}
			LWLockRelease(&queue->lwlock);
			break;
		}
	}
}

static bool
IsQueueEmpty(Queue *queue)
{
	bool isempty = false;
	LWLockAcquire(&queue->lwlock, LW_SHARED);
	if (queue->size == 0)
		isempty = true;
	LWLockRelease(&queue->lwlock);
	return isempty;
}

static bool
IsQueueFull(Queue *queue)
{
	bool isfull = false;
	LWLockAcquire(&queue->lwlock, LW_SHARED);
	if (queue->size == MaxQueueSize)
		isfull = true;
	LWLockRelease(&queue->lwlock);
	return isfull;
}

static void
RegisterBgExecutorQueue(Queue *queue)
{
	bool found = false;
	BgExecutorHashEnt *ent = NULL;
	ent = (BgExecutorHashEnt *) hash_search(
			bgExecutorHash, (const void *)&queue->executorId, HASH_ENTER, &found);
	Assert(found == false);
	ent->queue = queue;
}

/* Estimates the shared memory size used for background executor */
static Size
BgExecutorShmemSize(void)
{
	/*
	 * TODO: better estimation
	 */
	Size size = 0;
	size = add_size(size, sizeof(Queue));  // query source queue
	size = mul_size(size, bg_executor_total_numbers);
	return size;
}

static void
BgExecutorShmemInit(void)
{
	HASHCTL info;
	int hashFlags = 0;
	long maxTableSize = 1024;
	long initTableSize = 1024;

	/*
	 * Allocate the control structure for the hash table that maps
	 * background executor name to the address of it's queue.
	 */
	memset(&info, 0, sizeof(info));
	/* bgexecutor-xxxxxx(uuid) */
	info.keysize = sizeof(int32);
	info.entrysize = sizeof(BgExecutorHashEnt);
	info.hash = tag_hash;
	hashFlags = (HASH_ELEM | HASH_FUNCTION);

	LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
	bgExecutorHash = ShmemInitHash("Background executor hash", initTableSize,
			maxTableSize, &info, hashFlags);
	LWLockRelease(AddinShmemInitLock);

	if (prev_shmem_startup_hook != NULL)
	{
		prev_shmem_startup_hook();
	}
}

/*
 * Signal handler for SIGTERM
 *		Set a flag to let the main loop to terminate, and set our latch to wake
 *		it up.
 */
static void
bg_executor_sigterm(SIGNAL_ARGS)
{
	int			save_errno = errno;

	got_sigterm = true;
	SetLatch(MyLatch);

	errno = save_errno;
}

/*
 * Signal handler for SIGHUP
 *		Set a flag to tell the main loop to reread the config file, and set
 *		our latch to wake it up.
 */
static void
bg_executor_sighup(SIGNAL_ARGS)
{
	int			save_errno = errno;

	got_sighup = true;
	SetLatch(MyLatch);

	errno = save_errno;
}


static void
LaunchBackgroundExecutors(void)
{
	int32 i;
	Queue *queue = NULL;
	BackgroundWorker worker;
	BgwHandleStatus status;
	pid_t pid;
	MemoryContext oldContext;

	/* Init and register query data queue for each background worker */
	for (i = 1; i <= bg_executor_total_numbers; i++)
	{
		queue = InitQueue(i);
		RegisterBgExecutorQueue(queue);
	}

	/* We might be running in a short-lived memory context. */
	oldContext = MemoryContextSwitchTo(TopTransactionContext);
	bgExecutorHandles =	(BackgroundWorkerHandle **)
		palloc0(bg_executor_total_numbers * sizeof(BackgroundWorkerHandle *));
	/* restore previous memory context */
	MemoryContextSwitchTo(oldContext);

	/* set up common data for all our workers */
	worker.bgw_flags = BGWORKER_SHMEM_ACCESS |
		BGWORKER_BACKEND_DATABASE_CONNECTION;
	worker.bgw_start_time = BgWorkerStart_ConsistentState;
	worker.bgw_restart_time = BGW_NEVER_RESTART;
	worker.bgw_main = bg_executor_main;
	/* set bgw_notify_pid so that we can use WaitForBackgroundWorkerStartup */
	worker.bgw_notify_pid = MyProcPid;

	/*
	 * Now fill in worker-specific data, and do the actual registrations.
	 */
	for (i = 1; i <= bg_executor_total_numbers; i++)
	{
		snprintf(worker.bgw_name, BGW_MAXLEN, "bgexecutor-%06d", i);
		worker.bgw_main_arg = Int32GetDatum(i);
		if (!RegisterDynamicBackgroundWorker(&worker, &bgExecutorHandles[i - 1]))
		{
			ereport(WARNING, (errmsg("%s register fail", worker.bgw_name)));
		}
		else
		{
			status = WaitForBackgroundWorkerStartup(bgExecutorHandles[i - 1], &pid);
			if (status == BGWH_STOPPED)
				ereport(WARNING, (errmsg("could not start %s", worker.bgw_name)));
			if (status == BGWH_POSTMASTER_DIED)
				ereport(ERROR, (errmsg("cannot start %s without postmaster", worker.bgw_name)));
		}
	}
}


static void
TerminateBackgroundExecutors(void)
{
	int32 i;
	BgExecutorHashEnt *ent = NULL;

	for (i = 1; i <= bg_executor_total_numbers; i++)
	{
		ent = hash_search(bgExecutorHash, (const void *)&i, HASH_REMOVE, NULL);
		TerminateBackgroundWorker(bgExecutorHandles[i - 1]);
	}
	pfree(bgExecutorHandles);
	bgExecutorHandles = NULL;
}

void
bg_executor_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction, uint64 count)
{
	int32 i;
	BgExecutorHashEnt *ent = NULL;
	bool found = false;
	PlannedStmt *plannedStmt = NULL;
	StringInfo buf = NULL;

	/* start background executors if required */
	if (bgExecutorHandles == NULL)
	{
		ereport(LOG, (errmsg("launch background executor")));
		LaunchBackgroundExecutors();
		Assert(bgExecutorHandles != NULL);
	}

	plannedStmt = queryDesc->plannedstmt;
	buf = makeStringInfo();
	if (plannedStmt != NULL)
	{
		appendStringInfo(buf, "%s", nodeToString((Node *) plannedStmt));
	}
	else
	{
		appendStringInfo(buf, "%s", nodeToString(queryDesc->utilitystmt));
	}
	/*
	 * TODO: what to serialize and which queue to insert into?
	 */
	for (i = 1; i <= bg_executor_total_numbers; i++)
	{
		ent = hash_search(bgExecutorHash, (const void *)&i, HASH_FIND, &found);
		if (found)
		{
			EnQueue(ent->queue, buf);
			ereport(LOG, (errmsg("bgexecutor-%06d enqueue string:%s",
							i, buf->data)));
		}
	}

	/* fall back to standard executor */
	standard_ExecutorRun(queryDesc, direction, count);

	/* wait for background executors to finish */
	pg_usleep(bg_executor_naptime * 1000L);

	/* shut down background executors if required */
	if (bgExecutorHandles != NULL)
	{
		ereport(LOG, (errmsg("terminate background executor")));
		TerminateBackgroundExecutors();
	}
}

void
bg_executor_main(Datum main_arg)
{
	int32 executorId;
	Queue *queue = NULL;
	BgExecutorHashEnt *ent = NULL;
	bool found = false;

	executorId = DatumGetInt32(main_arg);

	/* Establish signal handlers before unblocking signals. */
	pqsignal(SIGHUP, bg_executor_sighup);
	pqsignal(SIGTERM, bg_executor_sigterm);

	/* We're now ready to receive signals */
	BackgroundWorkerUnblockSignals();

	/* Connect to our database */
	BackgroundWorkerInitializeConnection("luoyuanhao", NULL);

	/*
	 * Main loop: do this until the SIGTERM handler tells us to terminate
	 */
	while (!got_sigterm)
	{
		int			rc;

		/*
		 * Background workers mustn't call usleep() or any direct equivalent:
		 * instead, they may wait on their process latch, which sleeps as
		 * necessary, but is awakened if postmaster dies.  That way the
		 * background process goes away immediately in an emergency.
		 */
		rc = WaitLatch(MyLatch,
					   WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH,
					   bg_executor_naptime * 1000L,
					   PG_WAIT_EXTENSION);
		ResetLatch(MyLatch);

		/* emergency bailout if postmaster has died */
		if (rc & WL_POSTMASTER_DEATH)
		{
			proc_exit(1);
		}

		/*
		 * In case of a SIGHUP, just reload the configuration.
		 */
		if (got_sighup)
		{
			got_sighup = false;
			ProcessConfigFile(PGC_SIGHUP);
		}

		if (queue == NULL)
		{
			found = false;
			ent = hash_search(bgExecutorHash, (const void *)&executorId, HASH_FIND, &found);
			if (!found)
			{
				ereport(WARNING, (errmsg("bgexecutor-%06d can't find queue", executorId)));
			}
			else
			{
				queue = ent->queue;
			}
		}

		if (queue != NULL && !IsQueueEmpty(queue))
		{
			PlannedStmt *stmt = NULL;
			QueryDesc *queryDesc = NULL;
			Snapshot snap = NULL;
			Node *node = NULL;
			StringInfo buf = NULL;

			buf = makeStringInfo();
			DeQueue(queue, buf);
			ereport(LOG, (errmsg("bgexecutor-%06d dequeue string:%s",
							executorId, buf->data)));
			node = (Node *) stringToNode(buf->data);
			if (IsA(node, PlannedStmt))
			{
				StartTransactionCommand();

				stmt = (PlannedStmt *) node;
				if (ActiveSnapshotSet())
				{
					snap = GetActiveSnapshot();
				}
				else
				{
					snap = GetTransactionSnapshot();
				}
				/*
				 * TODO: create a proper QueryDesc(with sourceText, Snapshot,
				 * DescReceive and Params).
				 */
				queryDesc = CreateQueryDesc(
						stmt,
						NULL,
						snap,
						InvalidSnapshot,
						None_Receiver,
						NULL,
						0);
				/*
				 * Call ExecutorStart to prepare the plan for execution
				 */
				ExecutorStart(queryDesc, 0);
				/*
				 * Run the plan to completion.
				 * TODO: use custom executor.
				 */
				standard_ExecutorRun(queryDesc, ForwardScanDirection, 0L);
				/*
				 * Now, we close down all the scans and free allocated resources.
				 */
				ExecutorFinish(queryDesc);
				ExecutorEnd(queryDesc);
				FreeQueryDesc(queryDesc);

				CommitTransactionCommand();
			}
			else
			{
				ereport(LOG, (errmsg("dequeue is not a PlannedStmt")));
			}
		}
		else
		{
			/*
			 * TODO: any epoll strategy?
			 */
			pg_usleep(1 * 1000L);
		}
	}

	proc_exit(1);
}

/*
 * Entrypoint of this module.
 *
 * We register more than one worker process here, to demonstrate how that can
 * be done.
 */
void
_PG_init(void)
{
	if (!process_shared_preload_libraries_in_progress)
		return;

	DefineCustomIntVariable("bg_executor.total_numbers",
							"Number of background executors.",
							NULL,
							&bg_executor_total_numbers,
							bg_executor_total_numbers,
							1,
							100,
							PGC_POSTMASTER,
							0,
							NULL,
							NULL,
							NULL);


	if (ExecutorRun_hook != NULL)
	{
		ereport(ERROR, (errmsg("bg_executor has to be loaded first"),
					errhint("Place bg_executor at the beginning of "
						"shared_preload_libraries.")));
	}
	ExecutorRun_hook = bg_executor_ExecutorRun;

	/* organize and register initialization of required shared memory */
	RequestAddinShmemSpace(BgExecutorShmemSize());
	prev_shmem_startup_hook = shmem_startup_hook;
	shmem_startup_hook = BgExecutorShmemInit;
}
